Lista słów kluczowych:
  bool, byte, i8, i16, i32, i64, u8, u16, u32, u64,
  f32, f64, dyn, addr, arr, array, str, string,
  cp, const, var, shared, unique, mut, ref, str, arr,
  array, string, for, while, loop, endless, inv,
  func, lambda, type, struct, enum, main

Podstawowe typy trywialne:
  bool -- typ logiczny,
  byte -- bajt nieinterpretowany jako liczba,
  i8, i16, i32, i64 -- liczby całkowite ze znakiem,
  u8, u16, u13, u64 -- liczby całkowite bez znaku,
  f32, f64 -- liczby zmiennoprzecinkowe,
  shared<TYPE> -- typ dynamiczny kopiowalny, // działa jak shared_ptr
  unique<TYPE> -- typ dynamiczny niekopiowalny,
  addr<TYPE> -- typ wskaźnikowy.

    Zabronione są konwersje niejawne. Wszystkie typy trywialne są domyślnie kopiowalne.
    Typy złożone są domyślnie przenoszone, chyba że wymuszenie nastąpi użyciem identyfikatora cp.

Podstawowe typy złożone:
  arr<TYPE>[SIZE] -- typ statycznych tablic,
  array<TYPE> -- typ dynamicznych tablic (analogicznie string),
  str[SIZE] -- typ statycznych literałów znakowych,
  string -- typ dynamicznych łańcuchów znakowych (zarządzanie pamięcią zajmuje się kompilator).

Komentarze:
  // to jest komentarz

Konstrukcja obiektu danych:
  TYPE{} // konstrukcja domyślna
  TYPE{} // konstrukcja przez przeniesienie
  cp TYPE{} // konstrukcja przez skopiowanie
  // tablice omówione dalej

    Konstrukcja służy również jako wymuszenie jawnej konwersji

Typy nullable:
  TYPE? -- typ, który dodatkowo przechowuje informację, czy posiada wartość

  TYPE?{} // brak wartości
  TYPE?{TYPE{}} // posiada wartość

Definicja stałej symbolicznej za pomocą kwalifikatora const:
  const PI = i32{ 3,14 };

Definicja zmiennej niemodyfikowalnej:
  var variable = i32{ 7 };

Definicja zmiennej modyfikowalnej za pomocą kwalifikatora mut:
  var mutable_variable = mut i32{ 7 };

    Zmienne muszą być inicjalizowane, w przeciwnym razie błąd kompilacji.

Definicja referencji za pomocą kwalifikatora ref:
  var variable = ref i32{ other_variable };
  var variable = mut ref i32{ other_variable };

Definicja tablicy statycznej:
  var static_array = arr<u32>[SIZE]{}; // inicjalizacja wartościami domyślnymi, w tym przypadku 0
  var static_array = arr<u32>[SIZE]{1, 2}; // dwie pierwsze wartości dostarczone, reszta inicjalizacja wartościami domyślnymi
  var static_array = arr<u32>[]{1, 2}; // dwie wartości dostarczone

  var static_array = other_array; // dobrze, przeniesienie innej tablicy
  var static_array = cp other_array; //dobrze, kopia innej tablicy

  var multidimensional_static_array = arr<arr<u32>>[SIZE][SIZE]{}; // inicjalizacja wartościami domyślnymi
  // reszta tak samo jak jednowymiarowe

Definicja tablicy dynamicznej:
  var dynamic_array = array<u32>{};
  var dynamic_array = array<array<u32>>{};

Dynamiczna alokacja pamięci:
  var dynamic_variable = unique<u32>{} // dynamicznie zaalokowany u32, działa jak unique_ptr

Operatory arytmetyczne:
  OP++ -- postinkrementacja (unarny),
  ++OP -- preinkrementacja (unarny),
  OP-- -- postdekrementacja (unarny),
  --OP -- predekrementacja (unarny),
  +OP -- zmiana znaku na plus (unarny),
  -OP -- odwrócenie znaku (unarny),
  OP + OP -- dodawanie,
  OP - OP -- odejmowanie,
  OP * OP -- mnożenie,
  OP / OP -- dzielenie,
  OP % OP -- modulo.

Operatory bitowe:
  ~OP -- NOT unarny,
  OP & OP -- AND,
  OP | OP -- OR,
  OP << OP -- bitowe przesunięcie w lewo,
  OP >> OP -- bitowe przesunięcie w prawo.

Operatory logiczne:
  OP == OP -- równe,
  OP != OP -- różne,
  OP >= OP -- większe lub równe,
  OP <= OP -- mniejsze lub równe,
  OP < OP -- mniejsze,
  OP > OP -- większe,

  OP? -- czy wartość operandu to logiczna prawda oraz czy operand nullable ma wartość (unarny, powoduje konwersję do boola).

Inne operatory:
  OP.OP -- dostęp do pola składowego,
  OP[OP] -- operator indeksacji tablic,

  print^<TYPE>^ OP -- wypisanie na wyjście (unarny),
  read^<TYPE>^ OP -- odczytanie z wejścia do zmiennej modyfikowalnej (unarny).

Wyrażenie warunkowe if:
  if (condition?) {
    some_instruction;
    return_value
  }

  if (condition) {
    if (another_condition) {

    };
    return_value
  }
  else {
    return_value
  }

    W tym języku if jest wyrażeniem, a nie instrukcją tj. wartościowuje się do ostatniego wyrażenia w ciele.
    Wyrażenie, które jest brane pod uwagę, to wyrażenie nie mające średnika.
    Jeżeli if ma nie być wyrażeniem, kończymy go średnikiem.
    Jeżeli wyrażenie składa się z wielu członów (np. wiele else if, albo else na końcu), średnik stawiamy tylko po ostatniej gałęzi.

Pętle for:
  ^loop NAME =^ for (value : inclusive_start_value -> inclusive_target_value) {

  };

    Wersja iterująca od wartości do wartości.

  ^loop NAME =^ for (mut ref value : array) {

  };

    Wersja iterująca po elementach tablicy.

  ^loop NAME =^ for (initial_statement; condition; iteration_action) {

  };

    Wersja w stylu C.

    Opcjonalnych nazw pętli można użyć do przerywania zagnieżdżeń.

Pętla while:
  ^loop NAME =^ while (condition) {

  };

Nieskończona pętla loop:
  ^loop NAME =^ endless {

  };

Przerywanie zagnieżdżeń:
  loop main_loop = endless {
    loop {
      break main_loop;
    };
    loop {
      break;
    };
  };

Definicja funkcji:
  ^inv NAME =^ func^(PARAM_NAME = PARAM_TYPE, PARAM_NAME = PARAM_TYPE) ^-> ^RETURN_NAME =^ RETURN_TYPE^^ {
    some_instruction;
    return_value
  };

    Funkcja nie musi nic zwracać, wtedy pomijamy tę część zapisu.

Definicja wyrażenia lambda:
  ^inv NAME =^ lambda ^[catch_list](params) ^-> ^return_name =^ return_type^^ {body};

    Lambda nie musi nic zwracać, wtedy pomijamy tę część zapisu.

Definicja struktury:
  ^type NAME =^ struct {
    -var member = TYPE{};

    +inv member_fn = func ()->{};
  };

    W strukturze widoczność składowych określamy pisząc przed typem + (widoczne) lub - (niewidoczne).

Definicja typu wyliczeniowego:
  ^type NAME =^ enum {
    ENUMERATION, ENUMERATION //...
  };

Określenie punktu wejścia programu:
  ^inv PROGRAM_NAME =^ main ^(params) -> return^ {

  };






Przykładowy program:

  inv add = func(lhs = u32, rhs = u32) -> wynik = u32 {
    if (lhs == 55) {
      return 0; // early return
    }

    if (lhs == rhs) {
      print "Podałeś dwie takie same liczby, to podam ci coś innego";
      5
    }
    else {
      lhs + rhs
    }
  }

  inv SIMPLE_PROGRAM = main {
    var number = u32{};
    read<u32> number;

    if (number?) {
      print "To jest liczba różna od 0";
    }
    else {
      print "To jest zero";
    };

    print<u32> add(5, number);

    var numbers = arr<u32>[3]{number};
    print numbers;
    print numbers[0];

    for (value : u32{0} -> u32{50}) {
      print value; //wypisze od 0 do 50
    };
  };
